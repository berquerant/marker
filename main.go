package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames   = flag.String("type", "", "comma-separated list of type names; must be set")
	methodNames = flag.String("method", "", "comma-separated list of method names; must be set")
	output      = flag.String("output", "", "output file name; default srcdir/<type>_marker.go")
)

const usage = `Usage of marker:
  marker [flags] -type T -method M [directory]
  marker [flags] -type T -method M files...  # Must be a single package
Flags:
`

func Usage() {
	fmt.Fprintln(os.Stderr, usage)
	flag.PrintDefaults()
}

func isDirectory(p string) bool {
	x, err := os.Stat(p)
	if err != nil {
		log.Fatal(err)
	}
	return x.IsDir()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("marker: ")
	flag.Usage = Usage
	flag.Parse()

	if len(*typeNames) == 0 {
		log.Fatal("type must be set")
	}
	types := strings.Split(*typeNames, ",")
	if len(*methodNames) == 0 {
		log.Fatal("method must be set")
	}
	methods := strings.Split(*methodNames, ",")

	args := flag.Args()

	if len(args) == 0 {
		args = []string{"."}
	}
	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	g := Generator{}
	g.parsePackage(args)

	g.Printf("// Code generated by \"marker %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Println()
	g.Printf("package %s\n", g.pkg.name)
	g.Println()

	g.generateMulti(types, methods)

	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_marker.go", types[0])
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	if err := os.WriteFile(outputName, g.format(), 0600); err != nil {
		log.Fatalf("write file %v", err)
	}
}

type Generator struct {
	buf bytes.Buffer
	pkg *Package
}

func (s *Generator) Printf(format string, v ...interface{}) {
	fmt.Fprintf(&s.buf, format, v...)
}

func (s *Generator) Println(v ...interface{}) {
	fmt.Fprintln(&s.buf, v...)
}

type Package struct {
	name string
	defs map[string]bool
}

func (s *Generator) parsePackage(patterns []string) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedTypesInfo | packages.NeedTypes | packages.NeedName,
	}, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("%d packages found", len(pkgs))
	}
	s.addPackage(pkgs[0])
}

func (s *Generator) addPackage(pkg *packages.Package) {
	defs := map[string]bool{}
	for k, v := range pkg.TypesInfo.Defs {
		if v == nil {
			continue
		}
		if _, ok := v.Type().Underlying().(*types.Struct); !ok {
			continue
		}
		defs[k.String()] = true
	}
	s.pkg = &Package{
		name: pkg.Name,
		defs: defs,
	}
}

const methodTemplate = `func (*%[1]s) %[2]s() {}
`

func (s *Generator) generate(typeName, methodName string) {
	if _, exist := s.pkg.defs[typeName]; !exist {
		log.Fatalf("%s not found", typeName)
	}
	s.Printf(methodTemplate, typeName, methodName)
}

func (s *Generator) generateMulti(typeNames, methodNames []string) {
	for _, typeName := range typeNames {
		for _, methodName := range methodNames {
			s.generate(typeName, methodName)
		}
	}
}

func (s *Generator) format() []byte {
	src, err := format.Source(s.buf.Bytes())
	if err != nil {
		log.Fatalf("format failure %v", err)
	}
	return src
}
